# allbeingSort 众生排序算法

一种简单的排序算法。时间复杂度约为O(n * n!)。
一種簡單的排序演算法。時間複雜度約為O(n * n!)。
A simple sorting algorithm. The time complexity is approximately O(n * n!).
Простой алгоритм сортировки. Временная сложность составляет примерно O(n * n!).
シンプルなソートアルゴリズムです。時間の複雑さはおおよそO(n * n!)です。
간단한 정렬 알고리즘입니다. 시간 복잡도는 대략 O(n * n!)입니다.
Un algoritmo de ordenamiento simple. La complejidad temporal es aproximadamente O(n * n!).
Un algorithme de tri simple. La complexité temporelle est d'environ O(n * n!).
Ein einfacher Sortieralgorithmus. Die Zeitkomplexität beträgt etwa O(n * n!).
Un algoritmo di ordinamento semplice. La complessità temporale è approssimativamente O(n * n!).
Um algoritmo de ordenação simples. A complexidade de tempo é aproximadamente O(n * n!).
Een eenvoudig sorteeralgoritme. De tijdscomplexiteit is ongeveer O(n * n!).


在输入数组已经排序好的情况下，该算法的时间复杂度最低，为O(1)。
在輸入陣列已經排序好的情況下，該演算法的時間複雜度最低，為O(1)。
In the case where the input array is already sorted, the algorithm has the lowest time complexity of O(1).
В случае, когда входной массив уже отсортирован, алгоритм имеет наименьшую временную сложность O(1).
入力配列がすでにソートされている場合、アルゴリズムの時間の複雑さは最低でO(1)となります。
입력 배열이 이미 정렬되어 있는 경우, 알고리즘의 시간 복잡도는 O(1)로 가장 낮습니다.
En el caso de que el arreglo de entrada ya esté ordenado, el algoritmo tiene la menor complejidad temporal, O(1).
Dans le cas où le tableau d'entrée est déjà trié, l'algorithme a la plus faible complexité temporelle, O(1).
Wenn das Eingabearray bereits sortiert ist, hat der Algorithmus die geringste Zeitkomplexität von O(1).
Nel caso in cui l'array di input sia già ordinato, l'algoritmo ha la minima complessità temporale, O(1).
No caso em que o array de entrada já está ordenado, o algoritmo tem a menor complexidade de tempo, O(1).
In het geval dat de invoerarray al gesorteerd is, heeft het algoritme de laagste tijdscomplexiteit van O(1).
